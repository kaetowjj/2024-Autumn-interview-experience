# 京东方一面面经
主要是问简历里面技术内容，楼主投的职位是AI平台开发方向。

0. **自我介绍一下**
1. **MLAI绿色电池黑客马拉松里面你为什么想要使用svm**
    - 我分析一下选择使用SVM的原因:
    问题特点:
        + 电力交易和电池储能优化涉及多个特征(如价格模式、能源需求、存储水平等)的决策分类
        + 这些交易决策往往有明确的策略边界

    - SVM在这个场景的优势:
        + 善于在高维特征空间中找到清晰的决策边界,这对复杂的交易决策很有帮助
        + 适合处理能源市场通常提供的结构化数据
        + 相比一些更复杂的模型,SVM较不容易过拟合
        + 通过核函数可以处理线性和非线性关系
    - 不过我注意到最终DQN的表现更好。这说明该问题可能更适合用强化学习来优化序列决策 - 这在能源交易中往往是关键。
2. **介绍一下DQN**
让我详细介绍一下DQN (Deep Q-Network)：
    1. 基本概念
        1. DQN是深度强化学习的一种算法，它结合了深度神经网络和Q学习
        2. 主要用于解决具有连续状态空间的决策问题

    2. 核心工作原理
        1. 将状态作为输入传入深度神经网络
        2. 网络输出每个可能动作的Q值(期望收益)
        3. Agent根据Q值选择动作（通常使用ε-greedy策略）
        4. 通过与环境交互获得奖励，更新网络参数

    3. 关键创新点
        1. Experience Replay（经验回放）
            存储历史经验(状态、动作、奖励、下一状态)
            随机采样进行学习，打破数据相关性

        2. Target Network（目标网络）
            使用单独的网络计算目标Q值
            定期更新，提高训练稳定性

        3. 在电池优化中的应用优势
            可以处理连续的电价、电量等状态变量
            能够学习长期的优化策略，不仅考虑即时收益
            可以适应市场波动，形成动态的充放电决策
            通过经验积累不断改善策略

   4. 主要挑战
        需要大量训练数据和计算资源
        参数调优较为复杂
        训练过程可能不稳定

这就是为什么在你的电池项目中，DQN可能比SVM表现更好 - 它能更好地处理这种需要连续决策和长期规划的优化问题

3. **介绍一下python迭代器和生成器**
    - 迭代器(Iterator)：

        1. 定义：是一个实现了迭代器协议的对象，包含__iter__()和__next__()两个方法
        2. 特点：
            1. 可以记住遍历位置
            2. 只能往前遍历，不能后退
            3. 遍历到最后会抛出StopIteration异常
        3. 优点：节省内存，一次只获取一个元素

    - 生成器(Generator)：

        1. 定义：是一种特殊的迭代器，使用yield语句的函数就会变成生成器
        2. 特点：
            1.使用yield关键字来返回值
            2. 函数执行到yield会暂停，保存当前状态
            3. 下次调用会从暂停处继续执行
        3. 优点：
            1. 写法更简单，不用实现迭代器协议
            2. 内存效率高，按需生成数据
            3. 适合处理大数据集和无限序列
    - 主要区别：
        1. 生成器是创建迭代器的简单方式
        2. 生成器使用yield，迭代器需要实现特定方法
        3. 生成器会自动实现迭代器协议
        4. 生成器能更好地保存状态信息
    - 使用场景：
        1. 处理大文件
        2. 生成无限序列
        3. 需要节省内存的场景
        4. 数据流处理
4. **你熟悉python吗，为什么python的多线程是假多线程**
    + Python的threading模块完全可以创建真实的操作系统级线程。问题在于Python解释器的GIL（全局解释器锁）限制了这些线程的并行执行。在同一时刻，只有一个线程能够获得GIL并执行Python代码。

    + 这就导致即使你创建了多个线程，它们也无法真正并行执行

    + 所以说，Python的多线程并不是"假的"线程，而是受到了GIL的限制，无法充分发挥多核CPU的优势。这就是为什么在CPU密集型任务中，Python多线程的性能可能不如单线程。

    + 比较准确的说法应该是：Python支持真实的操作系统线程，但由于GIL的存在，这些线程无法实现真正的并行计算。

    - 拓展:
        1. GIL的本质：
            + GIL是Python解释器（CPython）中的一个互斥锁
            + 任何Python线程执行前，必须先获得GIL
            + 每执行100个字节码指令，Python解释器就会自动释放GIL
            + 这意味着在任何时刻，只有一个线程可以执行Python代码
        2. 为什么保留GIL：
            + 简化了Python解释器的实现
            + 避免了大量的锁操作，提高了单线程程序的执行效率
            + 保证了现有C扩展库的线程安全
        3. 解决方案：
            + 要获得真正的并行计算能力，通常建议使用multiprocessing模块，因为每个进程都有自己的Python解释器和内存空间，不受GIL的限制。
5. **你用什么c++版本**
c++11
6. **你可以说一下c++和c的区别吗**
From AI:
    1. 面向对象编程
        1. C++支持类、继承、多态、封装
        2. C是面向过程的语言，不支持OOP特性
    2. 内存管理
        1. C++有new/delete运算符
        2. C使用malloc/free函数
        3. C++11引入智能指针(unique_ptr, shared_ptr)进行自动内存管理
    3. 函数特性
        1. C++支持函数重载（同名不同参）
        2. C++支持默认参数
        3. C++支持引用传递，C只有值传递和指针传递
    4. 泛型编程
        1.C++支持模板，可以实现泛型编程
        2. C不支持泛型，需要为不同类型写不同函数
    5. 异常处理
        1. C++有try/catch异常处理机制
        2. C只能通过返回值和errno处理错误
    6. 标准库
        1. C++有STL（容器、算法、迭代器等）
        2. C的标准库相对简单，功能较少
    7. 类型安全
        1. C++更强调类型安全
        2. 支持const、static_cast、dynamic_cast等类型检查
        3. C的类型检查相对宽松
    8. 语言特性：
        1. C++11新增了auto关键字、lambda表达式、右值引用
        2. 支持范围for循环
        3. nullptr替代NULL
        4. 支持多线程（std::thread）
7. 另一个Hr问项目
8. 你有什么问题想问我
    - 面试官您好，我想了解一下京东方是如何培养新入职员工尽快熟悉他的工作的呢，比如AI平台开发方向。